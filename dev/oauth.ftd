-- ds.page: OAuth 2.0

- OAuth 2.0 and OpenID connect
- Simple login or forms auth
  - collect username and password via form
  - Hash password, verify hash, look up user info, look up auth info
  - save it to db -> Set-Cookie in the browser
  - Downsides
    - Security
    - Maintenance

- Identity use cases (pre-2010)
  - Simple login (forms and cookies)
  - Single sign-on across sites
  - Mobile app login
  - Delegated authorization
    - How can I let a website access my data without giving it my password.

- Delegated
- entrust (a task or responsibility) to another person, typically one who is
  less senior than oneself.
- send or authorize (someone) to do something as a representative.


# Delegated authorization with OAuth 2.0

I trust Gmail and I kind of trust Yelp. I want Yelp to have access to my contacts.

## How does google OAuth works

Yelp.com have a button Say [connect with google] that redirects user to
accounts.google.com, where user have to fill the email and password and then
google will ask that this application wants to access these and these things from
your account will you provide access, then user can choose yes or no, if user
chooses yes then yelo.com/callback(by passing code) and then yelp server will
call google server by passing this code and server secrets to get the access token
and set this to cookie.

## OAuth 2.0 Terminology

- Resource Owner
  - Who owns the data, meaning user who is owning the data.
- Client
  - Application where you are trying to logged-in using google auth, in this
  case, there is yelp.
- Authorization Server
  - accounts.google.com
- Resource Server
  - Where your data Apis exists
  - Where your resources actually stored, in this case there is google apis that
  client wants to access on user's behalf.
  - Sometimes authorization and resource server are the same thing but many times
  they are separate.
- Authorization Grant
  - Where user approves that I am giving permissions to access these resources
- Redirect Uri
  - Where authorization server redirects back to after successful login or failed
- Access Token
  - This token is used to access the data from resource server.
  - It depends on scope what resources you can access, using this access token.

-- ds.image:
src: $assets.files.static.oauth.OAuth-2-Flow.png
width: fill

-- ds.h2: More OAuth 2.0 terminology

- Scope
  - Authorization server have list of scopes like
    - contacts.read, contacts.update, email.read, email.delete, etc....
  - So client have to by passing these scopes what level of data you want to
  access and what do you want to do with the data, which apis you want to access.
- Consent
 - Based on that authorization server create a list of consent to the client.

Note: In the above approach we have used authorization code to get the access
token, why just we can get the access token.

-- ds.h2: Even More OAuth 2.0 terminology

- Back Channel(highly secured channel)
  - If I have server which only I have a access to and If I have made a secure
  call of my server to google server, meaning or less this is almost a secure call.
- Front Channel(less secured channel)
  - Like browser
  - Browsers are safe but there are some loop holes how did they get build.
  - People can check your cookie in the browser, can be copied and pasted.
  - If I have stored it in javascript, then somebody can also check it with view-src.
  - We can trust more on the our server, but not complete trust on a browser.
  - Someone looking from your shoulder can see this, they are not total secure.

Because access code comes with redirected URI's query parameters in the browser,
using this access code then abrark.com server will call authorization server
(accounts.google.com) to get the access token and redirect user with access-token.

In that case it is more secure because access token using the highly secure
channel. And it can also map this access token to something like it's own
token: `some-encrypted-id`, and not passing the actual token which authorization
server is sharing with you.
